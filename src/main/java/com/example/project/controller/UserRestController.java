package com.example.project.controller;

import com.example.project.engine.Producer;
import com.example.project.model.JsonMessage;
import com.example.project.model.Storic;
import com.example.project.model.User;
import com.example.project.repository.UserRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.*;

import javax.annotation.PostConstruct;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Slf4j
@RestController
@EnableScheduling
@RequestMapping("/users")
public class UserRestController {

    @Autowired
    private UserRepository userRepository;
    @Autowired
    private Producer producer;

    @Autowired
    UserRestController(Producer producer) {
        this.producer = producer;
    }

    private final String USER_ID = "/{id}";
    private final String GET_BY_USERNAME = "/getUsername/{username}";

    @PostConstruct
    private void initUsers() {
        if (userRepository.count() == 0) {
            User Dionis = User.builder().username("Dionis").email("topallidionis.dt@gmail.com")
                    .name("Dionis").surname("Topalli")
                    .phone("").fiscalCode("")
                    .creation(LocalDateTime.now()).build();
            userRepository.insert(Dionis);
        }
    }

    @GetMapping(USER_ID)
    public ResponseEntity<User> getById(@PathVariable String id) {
        Optional<User> user = userRepository.findById(id);
        if (user.isPresent()) {
            return new ResponseEntity<>(user.get(), HttpStatus.OK);
        }else{
            log.warn("USER NOT FOUND on DB with this ID {}",id);
            return new ResponseEntity<>(null,HttpStatus.NOT_FOUND);
        }
    }

    @GetMapping(GET_BY_USERNAME)
    public Optional<User> getByUsername(@PathVariable String username) {
        return userRepository.findByUsername(username);
    }

    @GetMapping()
    public List<User> getAll() {
        return userRepository.findAll();
    }


    @PostMapping()
    public ResponseEntity<JsonMessage> add(@RequestBody User user) {
        try {
            Storic storic=new Storic();
            Optional<User> username = userRepository.findByUsernameOrFiscalCode(user.getUsername(), user.getFiscalCode());
            if (username.isEmpty()) {
                if (StringUtils.isEmpty(user.getEmail().trim()) || StringUtils.isEmpty(user.getFiscalCode().trim())
                        || StringUtils.isEmpty(user.getUsername().trim())) {
                    return new ResponseEntity<>(new JsonMessage("Username or email or fiscalcode are empty"),
                            HttpStatus.BAD_REQUEST);
                } else {
                    user.setCreation(LocalDateTime.now());
                    userRepository.insert(user);
                    storic.setDate(LocalDateTime.now());
                    storic.setNewUser(user);
                    storic.setDetails("Insert User");
                    this.producer.sendMessage(storic);
                    return new ResponseEntity<>(new JsonMessage("Performed"), HttpStatus.OK);
                }
            } else {
                return new ResponseEntity<>(new JsonMessage("User with this username or fiscalcode already exist, please change it"),
                        HttpStatus.BAD_REQUEST);
            }
        } catch (Exception e) {
            log.error("ERROR ADD USER {}", user.toString(), e);
            return new ResponseEntity<>(new JsonMessage("Error"), HttpStatus.CONFLICT);
        }
    }

    @PutMapping(USER_ID)
    public ResponseEntity<JsonMessage> update(@PathVariable String id, @RequestBody User userBody) {
        try {
            Storic storic =new Storic();
            Optional<User> user = userRepository.findById(id);
            if (user.isPresent()) {
                if (userBody.getUsername().isBlank() || userBody.getEmail().isBlank() || userBody.getFiscalCode().isBlank()) {
                    return new ResponseEntity<>(new JsonMessage("Username, email and fiscalcode  are mandatory"), HttpStatus.OK);
                }
                userBody.setId(user.get().getId());
                userRepository.save(userBody);
                storic.setDate(LocalDateTime.now());
                storic.setNewUser(userBody);
                storic.setOldUser(user.get());
                storic.setDetails("Updated User");
                this.producer.sendMessage(storic);
                return new ResponseEntity<>(new JsonMessage("User updated"), HttpStatus.OK);

            } else {
                return new ResponseEntity<>(new JsonMessage("User with this id not exist"), HttpStatus.BAD_REQUEST);
            }
        } catch (Exception e) {
            log.error("ERROR UPDATE USER {}", userBody.toString(), e);
            return new ResponseEntity<>(new JsonMessage("Error, please contact administrator"), HttpStatus.OK);
        }
    }

    @DeleteMapping(USER_ID)
    public ResponseEntity<JsonMessage> delete(@PathVariable String id) {
        try {
            Optional<User> user = userRepository.findById(id);
            if (user.isEmpty()) {
                return new ResponseEntity<>(new JsonMessage("Id not present on DB"), HttpStatus.BAD_REQUEST);
            } else {
                userRepository.deleteById(id);
                return new ResponseEntity<>(new JsonMessage("User deleted"), HttpStatus.OK);
            }
        } catch (Exception e) {
            log.error("ERROR DELETE USER BY ID {}", id, e);
            return new ResponseEntity<>(new JsonMessage("Error"), HttpStatus.CONFLICT);
        }
    }
}
